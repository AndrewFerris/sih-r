transition_matrix <- matrix(c(1,2,3,4,5,6,7,8,9),nrow = 3, ncol = 3)
row.names(transition_matrix) <- c("A", "B", "C")
colnames(transition_matrix) <- c("D", "E", "F")
View(transition_matrix)
library(sihr)
Sys.info()
version
library(sihr)
getwd()
data_rp_table <- data.frame(c("A1", "A1", "A1", "B1", "C1"),
c("A2", "C2", "C2", "A2", "B2"),
c("C3", "C3", "A3", "A3", "A3"),
c("C4", "C4", "A4", "B4", "C4"),
c(1,2,3,4,5),
stringsAsFactors = F)
row.names(data_rp_table) <- c("R1", "R2", "R3", "R4", "R5")
colnames(data_rp_table) <- c("Col1", "Col2", "Col3", "Col4", "Col5")
data_rp_table <- as.matrix(data_rp_table)
save(data_rp_table, file="data/data_rp_table.RData")
data_t_mat_rp <- matrix(c(1,2,3,4,5,6,7,8,9),nrow = 3, ncol = 3)
row.names(data_t_mat_rp) <- c("A", "B", "C")
colnames(data_t_mat_rp) <- c("D", "E", "F")
save(data_t_mat_rp, file="data/data_t_mat_rp.RData")
library(sihr)
library(sihr)
library(sihr)
library(sihr)
library(sihr)
library(sihr)
library(sihr)
library(sihr)
library(sihr)
library(sihr)
data_t_mat_rp <- matrix(c(1,2,3,4,5,6,7,8,9),nrow = 3, ncol = 3)
row.names(data_t_mat_rp) <- c("A", "B", "C")
colnames(data_t_mat_rp) <- c("D", "E", "F")
save(data_t_mat_rp, file="data/data_t_mat_rp.rda")
data_rp_table <- data.frame(c("A1", "A1", "A1", "B1", "C1"),
c("A2", "C2", "C2", "A2", "B2"),
c("C3", "C3", "A3", "A3", "A3"),
c("C4", "C4", "A4", "B4", "C4"),
c(1,2,3,4,5),
stringsAsFactors = F)
row.names(data_rp_table) <- c("R1", "R2", "R3", "R4", "R5")
colnames(data_rp_table) <- c("Col1", "Col2", "Col3", "Col4", "Col5")
data_rp_table <- as.matrix(data_rp_table)
save(data_rp_table, file="data/data_rp_table.rda")
library(sihr)
library(sihr)
library(sihr)
library(sihr)
library(sihr)
library(sihr)
?library
library(sihr)
.libPaths()
install.packages("riverplot")
?install.packages
.libPaths()
.libPaths()[1]
.libPaths()[2]
install.packages("riverplot", lib = .libPaths()[2])
riverplot::riverplot
cats_go_meow <- function (x, direction = "lr", lty = 0, default_style = NULL,
gravity = "top", node_margin = 0.1, nodewidth = 1.5, plot_area = 0.5,
nsteps = 50, add_mid_points = NULL, xscale = 1, yscale = "auto",
mar = c(0, 0, 0, 0), add = FALSE, usr = NULL, fix.pdf = FALSE,
...)
{
ds <- list(...)
default_style <- getstyle(ds, defaults = default_style)
direction <- match.arg(direction, c("lr", "rl"))
if (!add)
plot.new()
dmsgc("--------------\nDefault style:\n-----------\n")
dmsg(default_style)
dmsgc("--------------\n")
x2 <- x
x2$nodes$ID <- as.character(x2$nodes$ID)
dmsg("checking edges")
x2$edges <- checkedges(x2$edges, names(x2))
x2 <- orderConnections(x2)
if (is.null(add_mid_points) && !ypos_present(x2)) {
dmsg("adding mid points")
x2 <- add_mid_points(x2)
}
for (n in c(x2$nodes$ID, x2$edges$ID)) {
x2$styles[[n]] <- getstyle(x2$styles[[n]], default_style,
update.missing = FALSE)
}
dmsgc("Updated styles:\n")
dmsg(x2$styles)
dmsgc("--------------\n")
if (yscale == "auto")
yscale <- autoscale(x2)
if (yscale != 1)
x2$edges$Value <- x2$edges$Value * yscale
dmsg("calculating sizes")
sizes <- calcsizes2(x2)
dmsg(sizes)
dmsg("calculating positions")
positions <- calcpos(x2, sizes, gravity = gravity, node_margin = node_margin)
dmsg("done")
xrange <- range(x2$nodes$x)
xlim <- xrange + (xrange[2] - xrange[1]) * c(-0.1, 0.1)
ylim <- range(positions[c("bottom", "top"), ])
b <- (ylim[2] - ylim[1]) * (1 - plot_area)/plot_area/2
ylim <- ylim + c(-b, b)
if (!is.null(mar))
oldmar <- par(mar = mar)
l <- names(x2$nodes)[order(x2$nodes)]
dev.hold()
on.exit({
dev.flush()
par(oldmar)
})
w <- strwidth("hjKg") * nodewidth/2
if (is.null(usr))
usr <- par("usr")
xscale <- xscale * (usr[2] - usr[1])/(xlim[2] - xlim[1])
yscale <- (usr[4] - usr[3])/(ylim[2] - ylim[1])
positions[1, ] <- (positions[1, ] - xlim[1]) * xscale + usr[1]
if (direction == "rl") {
positions[1, ] <- usr[2] - positions[1, ]
}
positions[2:6, ] <- (positions[2:6, ] - ylim[1]) * yscale +
usr[3]
dmsg("drawing edges")
fix.pdf <- as.numeric(fix.pdf)
draw.edges(x2, positions, lty = lty, nsteps = nsteps, boxw = w,
yscale = yscale, fix.pdf = fix.pdf)
dmsg("drawing nodes")
draw.nodes(x2, positions, boxw = w, lty = lty)
return(invisible(positions))
}
?getstyle
??getstyle
?dmsg
??dmsg
rp_table(data_rp_table)
rp_table <- function(table = table){
#create the edges object
obj <- table[,1:ncol(table) - 1]
N1 <- gdata::unmatrix(obj[,c(1:ncol(obj) - 1)])
N2 <- gdata::unmatrix(obj[,c(2:ncol(obj))])
Value <- rep(table[,c(ncol(table))], ncol(obj) - 1)
edges <- data.frame(N1, N2, Value, stringsAsFactors = F)
row.names(edges) <- NULL
edges <- as.data.frame(edges %>%
group_by(N1, N2) %>%
summarise(Value = sum(as.integer(Value))))
#create the nodes objects
ID = NULL
x = NULL
y = NULL
for(i in 2:ncol(table) - 1){
ID <- c(ID, unique(table[,i]))
x <- c(x, rep(i, length(unique(table[,i]))))
y <- c(y, seq(1, length(unique(table[,i]))))
}
nodes <- data.frame(ID, x, y, stringsAsFactors = F)
rownames(nodes) = nodes$ID
#create the riverplot objects
rp <- list(nodes = nodes, edges = edges)
class(rp) <- c(class(rp), "riverplot")
#plot object
op <- par(cex=0.5)
plot(rp)
par(op)
r_list <- list(nodes = nodes, edges = edges)
return(r_list)
}
rp_table(data_rp_table)
#' @name rp_table
#'
#' @title Create a Sankey Plot from Table
#'
#' @description Create a Sankey Plot from Table
#'
#' This function takes a n x m matrix where the first m - 1
#' columns are character factors and the final m column is
#' a numeric value to create a riverplot (sankey plot) over
#' the riverplot function in the package riverplot. At this
#' time style information is missing from the riverplot,
#' with a view to use RColorBrewer to develop palettes
#' which can be used to make the plotting more clear.
#'
#' @section Known Problems:
#' There is no style input at this time. This means that
#' all Sankey plots come out as greyscale.
#' Labels are not wrapped and hard to clear, making the
#' interpretation of the image difficult.
#' Variables are also no ordered, meaning that "rivers"
#' may not be straight even though they should be.
#'
#' @param table A table of class matrix with m colums
#' where the first m - 1 columns are character and the
#' final m column is numeric/integer.
#'
#' @return A Sankey Plot
#' @return The Sankey Plot object, a list of edges and
#' nodes.
#'
#' @author Andrew Ferris
#'
#' @example rp_table(data_rp_table)
#'
#' @export
globalVariables(c("unmatrix", "group_by", "summarise", "par", "plot"))
#load the required packages
library(gdata, quietly = TRUE, warn.conflicts = FALSE)
library(riverplot, quietly = TRUE, warn.conflicts = FALSE)
library(dplyr, quietly = TRUE, warn.conflicts = FALSE)
library(RColorBrewer, quietly = TRUE, warn.conflicts = FALSE)
rp_table <- function(table = table){
#create the edges object
obj <- table[,1:ncol(table) - 1]
N1 <- gdata::unmatrix(obj[,c(1:ncol(obj) - 1)])
N2 <- gdata::unmatrix(obj[,c(2:ncol(obj))])
Value <- rep(table[,c(ncol(table))], ncol(obj) - 1)
edges <- data.frame(N1, N2, Value, stringsAsFactors = F)
row.names(edges) <- NULL
edges <- as.data.frame(edges %>%
group_by(N1, N2) %>%
summarise(Value = sum(as.integer(Value))))
#create the nodes objects
ID = NULL
x = NULL
y = NULL
for(i in 2:ncol(table) - 1){
ID <- c(ID, unique(table[,i]))
x <- c(x, rep(i, length(unique(table[,i]))))
y <- c(y, seq(1, length(unique(table[,i]))))
}
nodes <- data.frame(ID, x, y, stringsAsFactors = F)
rownames(nodes) = nodes$ID
#create the riverplot objects
rp <- list(nodes = nodes, edges = edges)
class(rp) <- c(class(rp), "riverplot")
#plot object
op <- par(cex=0.5)
plot(rp)
par(op)
r_list <- list(nodes = nodes, edges = edges)
return(r_list)
}
rp_table(data_rp_table)
cats_go_meow <- function (x, direction = "lr", lty = 0, default_style = NULL,
gravity = "top", node_margin = 0.1, nodewidth = 1.5, plot_area = 0.5,
nsteps = 50, add_mid_points = NULL, xscale = 1, yscale = "auto",
mar = c(0, 0, 0, 0), add = FALSE, usr = NULL, fix.pdf = FALSE,
...)
{
ds <- list(...)
default_style <- getstyle(ds, defaults = default_style)
direction <- match.arg(direction, c("lr", "rl"))
if (!add)
plot.new()
x2 <- x
x2$nodes$ID <- as.character(x2$nodes$ID)
x2$edges <- checkedges(x2$edges, names(x2))
x2 <- orderConnections(x2)
if (is.null(add_mid_points) && !ypos_present(x2)) {
x2 <- add_mid_points(x2)
}
for (n in c(x2$nodes$ID, x2$edges$ID)) {
x2$styles[[n]] <- getstyle(x2$styles[[n]], default_style,
update.missing = FALSE)
}
if (yscale == "auto")
yscale <- autoscale(x2)
if (yscale != 1)
x2$edges$Value <- x2$edges$Value * yscale
sizes <- calcsizes2(x2)
positions <- calcpos(x2, sizes, gravity = gravity, node_margin = node_margin)
xrange <- range(x2$nodes$x)
xlim <- xrange + (xrange[2] - xrange[1]) * c(-0.1, 0.1)
ylim <- range(positions[c("bottom", "top"), ])
b <- (ylim[2] - ylim[1]) * (1 - plot_area)/plot_area/2
ylim <- ylim + c(-b, b)
if (!is.null(mar))
oldmar <- par(mar = mar)
l <- names(x2$nodes)[order(x2$nodes)]
dev.hold()
on.exit({
dev.flush()
par(oldmar)
})
w <- strwidth("hjKg") * nodewidth/2
if (is.null(usr))
usr <- par("usr")
xscale <- xscale * (usr[2] - usr[1])/(xlim[2] - xlim[1])
yscale <- (usr[4] - usr[3])/(ylim[2] - ylim[1])
positions[1, ] <- (positions[1, ] - xlim[1]) * xscale + usr[1]
if (direction == "rl") {
positions[1, ] <- usr[2] - positions[1, ]
}
positions[2:6, ] <- (positions[2:6, ] - ylim[1]) * yscale +
usr[3]
fix.pdf <- as.numeric(fix.pdf)
draw.edges(x2, positions, lty = lty, nsteps = nsteps, boxw = w,
yscale = yscale, fix.pdf = fix.pdf)
draw.nodes(x2, positions, boxw = w, lty = lty)
return(invisible(positions))
}
riverplot.example
cats_data <- function ()
{
ret <- list(nodes = data.frame(ID = LETTERS[1:8],
x = c(1, 2, 2, 3, 3, 4, 5, 1),
labels = c(NA, NA, "Node C", rep(NA, 4), "Node H"),
stringsAsFactors = FALSE),
styles = list(A = list(col = "#00990099",
lty = 0,
textcol = "white"),
H = list(col = "#FF000099",
textcol = "white"),
B = list(col = "#00006699",
textcol = "white"),
F = list(col = "yellow"),
D = list(col = "#00FF0099")))
ret$edges <- data.frame(N1 = c("A", "A", "A", "H", "H", "H", "B", "B", "C", "C", "C"),
N2 = c("B", "C", "D", "D", "F", "G", "D", "F", "D", "E", "F"),
Value = c(10, 20, 5, 10, 10, 20, 5, 10, 20, 15, 10),
stringsAsFactors = F)
rownames(ret$nodes) <- ret$nodes$ID
class(ret) <- c(class(ret), "riverplot")
return(ret)
}
cats_go_meow(cats_data())
default.style
install.packages("datapack")
library(datapack)
?checkedges
??checkedges
install.packages("QPress")
draw.edges
?draw.edges
??draw.edges
?draw
??draw
plot.function
?range
test <- (...)
test <- list(...)
ds <- list(...)
orderConnections
?orderConnections
??orderConnections
positions
?positions
??positions
install.packages("RFmarkerDetector")
library(RFmarker)
library(RFmarkerDetector)
ypos_present
?ypos_present
??ypos_present
